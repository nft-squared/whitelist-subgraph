"https://thegraph.com/docs/en/developer/create-subgraph-hosted/"
type Account @entity {
    "user information"
    id: ID!
    referenceCode: String!
    isVIP: Boolean!
    auths: [Auth!] @derivedFrom(field: "account")
    whitelisted: [RoundWinner!] @derivedFrom(field: "winner")
}

type Auth @entity {
    "user authorized tokens"
    id: ID!
    account: Account!
    txHash: String!
    tokenAddr: String!
    tokenID: Int!
}

type Bucket @entity {
    "bucket"
    id: ID!
    state: BucketState!
    txHash: Bytes!
    creator: Account!
    uri: String!
    name: String!
    description: String!
    discord: String!
    twitter: String!
    website: String!
    whitelistPerRound: Int!
    numRounds: Int!
    mintPrice: Int!
    mintToken: String!
    blockchain: String!
    launchDate: Int!
    referral: String

    createTime: Int!
    rounds: [BucketRound!] @derivedFrom(field: "bucket")
}

type SearchTicket @entity {
    id: ID!
    bucketRound: BucketRound!
    user: Account!
    accumulateTicktes: Int!
}

type UserRoundTicket @entity {
    id: ID!
    bucketRound: BucketRound!
    amount: Int!
}

type BucketRound @entity {
    "bucket rounds"
    id: ID!
    rnd: BigInt
    state: RoundState!
    bucket: Bucket!
    round: Int!
    tickets: Int!
    raffleTime: Int
    searchLength: Int!
    searchTickets: [SearchTicket!] @derivedFrom(field: "bucketRound")
    userTickets: [UserRoundTicket!] @derivedFrom(field: "bucketRound")
    result: [RoundWinner!] @derivedFrom(field: "round")
}

type RoundWinner @entity {
    "raffle result"
    id: ID!
    round: BucketRound!

    winner: Account!
    numberWhitelist: Int!
}

enum BucketState {
    pending
    active
    closed
}

enum RoundState {
    pending
    done
}

type Epoch @entity {
    "epoch information, including weights and timestamp"
    id: ID!
    epoch: Int!
    state: EpochState
    weights: [TokenWeight!]! @derivedFrom(field: "epoch")

    startTimestamp: Int!
    nextEpoch: Int!
    nextTimestamp: Int!
}

type TokenWeight @entity {
    "token weight for each epoch"
    id: ID!
    epoch: Epoch
    tokenAddress: String!
    weight: Int!
}

enum EpochState {
    active
    transitioning
    expired
}

type System @entity {
    "pricing and constant"
    id: ID!
    bonusBaseMulti: Int!
    bonusReferMulti: Int!
    bonusVIPMulti: Int!
    bonusReferalMulti: Int!
    bonusDenom: Int!

    bucketPrice: BigDecimal!
}
